// 프로젝트 코드리뷰
// 담당파트 : Landing Page
// 개발 기간 : 10/27 ~ now

// React 배경 : (*모듈성, *관리성(디버깅, 유지보수), *다양성) 
 > 페이스북에서 개발한 유저인터페이스 라이브러리로서 개발자로 하여금 재사용 가능한 UI를 생성 할 수 있게 해줍니다. 
   이 라이브러리는 현재 페이스북, 인스타그램, 야후, 넷플릭스를 포함한 많은 큰 서비스에서 사용되고 있습니다.

> 특징 : 
    (1) 화면 view단을 구현하기 위한 최소단위로 재사용가능한 component를 사용
    (2) component를 조립하여 완성된 view를 만듬(import, export)
    (3) JSX(Javascript XML) 사용
        >> 특징 : Javascript에서 확장한 문법, ( const, div 앨리먼트를 만들수있는 )
    (4) 단방향 데이터 바인딩 ( 부모->자식으로서의 데이터흐름)
        >>  그렇기 때문에 디버깅이 용이하며, 다른 라이브러리에 비해 안전성이 높다.
    (5) Class, functional 각각 사용법으로 프로젝트를 만들수있다.

    * SPA(Single Page Application) : 
    뜻 : 말 그대로 한 개의 페이지로 이루어진 애플리케이션이라는 의미입니다.

    기존 웹페이지 로딩방식의 단점 :
    * 트래픽이 너무 많이 나올 수 있다.
        (=비교적 안나온다.)
    * 사용자가 몰려 서버에 높은 부하가 나올 수 있다.
        (=서버에 높은 부하가 나오지 않는다.)
    * 화면전환이 일어날 때마다 HTML을 계속 서버에 요청하면 사용자의 상태를 유지하기 힘들다.
        (=리액트는 사용자의 상태를 유지하기 쉽다.)
    * 바뀌지 않는 부분까지 새로 불러와서 보여줘야해서 불필요한 로딩이 있어 비효율적이다.
        (=리액트는 바뀌는 부분만 새로 불러와서 효율적이다.)


    장점 : 뷰 렌더링을 사용자의 브라우저가 담당하고,
           사용자와의 인터랙션(상호작용)이 발생하면 필요한 부분만 자바스크립트를 사용하여 업데이트 한다.

    단점 : 규모가 커지면 파일 또한 거대해진다
    * 가상 DOM을 활용하여 부분적인 렌더링을 하는 자바스크립트 라이브러리

    *** 문서 객체 모델(The Document Object Model, DOM) 은 HTML, XML 문서의 프로그래밍 interface이다. ***
        .내가 작성한 HTML 코드가 DOM이다
        .페이지 View Source가 DOM이다
        .DevTools에서 보이는 코드가 DOM이다.
    >> 결론 : 내가 코딩한 것들이 브라우저에 의해 파싱하면 DOM이다

 > 장점 : 
    1. React는 JavaScript 객체 형태의 Virtual DOM 을 사용하여 어플리케이션의 성능을 향상시킴 (JavaScript Virtual DOM 처리가 실제 DOM 보다 빠르기 때문)
        >> Virtual DOM이란? : 
            목록을 다시 작성하는 것은 웹 브라우저에 큰 문제가 아니지만 최신 웹 사이트는 엄청난 양의 DOM 조작을 사용할 수 있습니다. 
            비효율적인 업데이트는 심각한 문제가되었고, 그것을 자동적으로 보다 편리하게 관리하게 해주는것을 가상DOM이라합니다.
        >> 왜 쓰는거지? :  
            > DOM 관리를 Virtual DOM 이 하도록 함으로써, 
            컴포넌트가 DOM 조작 요청을 할 때 다른 컴포넌트들과 상호작용을 하지 않아도 되고, 
            특정 DOM 을 조작할 것 이라던지, 이미 조작했다던지에 대한 정보를 공유 할 필요가 없습니다. 
            즉, 각 변화들의 동기화 작업을 거치지 않으면서도 모든 작업을 하나로 묶어줄 수 있다는거죠.
        >> 동작 :
            1. 전체 가상 DOM이 업데이트됩니다.
            2. 가상 DOM은 업데이트하기 전의 모습과 비교됩니다. React는 어떤 개체가 변경되었는지 파악합니다.
            3. 변경된 객체와 변경된 객체 만 실제 DOM 에서 업데이트됩니다 .
            4. 실제 DOM이 변경되면 화면이 변경됩니다.


    2. 서버 & 클라이언트 사이드 렌더링 지원을 통해 브라우저측의 초기 렌더링 딜레이를 줄이고, 
       SEO 호환(검색엔진 최적화)도 가능해짐

       React는 SPA를 지원하는 라이브러리이고, 클라이언트사이드 렌더링으로 이루어진다.

    3. Component 의 가독성이 매우 높고 간단하여 쉬운 유지보수, 간편한 UI 수정 및 재사용 용이

    4. React는 프레임워크가 아닌 라이브러리기 때문에 다른 프레임워크와 혼용 가능

 > 단점 : 
    1. VIEW ONLY , VIEW 이외의 기능은 써드파티 라이브러리(Third party library, =패키지, 모듈로 불리기도함)를 이용하거나 직접 구현해야함
    2. IE8 이하 지원하지 않음 (IE8 이하 버전을 지원해야 할 경우 v0.14 버전을 사용 해야함)
    3. React는 inline-template 과 JSX 를 사용하는데, 일부 개발자들에게는 적응이 안 될 수 있음

 ** 자신이 실제로 사용하면서 느낌점:
        컴포넌트간에 모듈성으로 인해 웹페이지를 손쉽게 유지보수 할수있으며, 
        여러가지의 언어를 혼용해서 사용할수 있다는 것이 특징이라 생각합니다.

        * HOC(Higher Order Component) : 고차 컴포넌트 *
                컴포넌트(HOC)는 컴포넌트를 인수로 받아 컴포넌트를 반환하는 컴포넌트이다. 
                HoC는 매개변수로 받은 컴포넌트에 기능을 추가해서 새로운 컴포넌트를 반환한다.

                쉽게 말해, 화면에서 재사용 가능한 로직만을 분리해서 component로 만들고, 
                재사용 불가능한 UI와 같은 다른 부분들은 parameter로 받아서 처리하는 방법입니다.

                문제점 : 고차컴포넌트를 계속 사용하다보면 정말 끝도없이 컴포넌트들이 묶여있는데, 
                그것을 해결하는 것이 함수형 컴포넌트에서는 Hook을 사용하는것입니다


        * HOF(Higher-Order Function) :고차 함수 *
            학과 컴퓨터 과학에서 고차 함수는 하나 이상의 함수를 인수로 가지거나 함수를 결과로 반환하는 함수이다. 
            다른 모든 함수들은 일차 함수이다.


            과거 헷갈렸던 부분:
            >>  매개변수(parameter) : 매개변수는 함수의 정의부분에 나열되어 있는 변수들을 의미하며, 
            >>  전달인자(argument) :  전달인자는 함수를 호출할때 전달되는 실제 값을 의미한다. 

                이같은 의미를 명확히 하기 위해 매개변수는 변수(variable)로, 
                전달인자는 값(value)으로 보는 것이 일반적이다.

                매개변수는 함수의 정의 부분에서 볼 수 있으며, 전달인자는 함수를 호출하는 부분에서 볼 수 있다. 
                f(x) = x*x와 같은 함수 정의 부분에서 변수 'x'가 매개변수가 되며, 
                f(2)와 같은 함수 호출 부분에서 값 '2' 가 함수의 전달인자가 된다.

        * 여러 state 변수 선언.

// React Class, function 왜나눠 질까?
 > 각 장단점.
    * class : 
    장점.
        1. state, lifeCycle 관련 기능사용 가능하다.
        2. 메모리 자원을 함수형 컴포넌트보다 조금 더 사용한다.
        3. 임의 메서드를 정의할 수 있다.
            >> constructor 안에서 this.state 초기 값 설정 가능
            >> constructor 없이 바로 state 초기값을 설정할 수 있다.
            >> this.setState 함수로 state의 값을 변경할 수 있다.
        4. 이벤트 핸들링
            >> 함수 선언시 에로우 화살로 바로 선언 가능하다.
            >> 요소에서 적용하기 위해서는 this를 붙여야한다

    단점.
        1. "this" + (props, state)를 붙여서 사용한다는점
        2. 코드가 길어지고, 복잡해진다


    * function :
    장점.
        1. 함수형 컴포넌트는 클래스형 컴포넌트보다 선언하기가 좀 더 편하다.
        2. 메모리 자원을 덜 사용한다는 장점 
        3. ES6의 화살표 함수(arrow function) 방식
            >> 일반 함수는 자신이 종속된 객체를 this로 가리키며, 화살표 함수는 자신이 종속된 인스턴스를 가리킨다.
        4. hook을 사용한 데이터 전달
            >> useState, useEffect, use.....같은 기능을 사용함으로써 코드간소화와 효율적인 데이터전달이 가능하다. 
        5. 이벤트 핸들링
            >> const 키워드 + 함수 형태로 선언 해야한다.
            >> props에 this. 를 써줄필요가 없다.

    단점. 
        1. 클래스형식처럼 세밀한 라이프사이클 작업을 필요로 할때 Hook으로 사용하기에는 디테일함이 부족하다.

 > 나는 왜 function을 사용한것일까?
    >> 학원에서 처음접했던 방식이 함수형 컴포넌트이고, 전체적인 구조가 class보단 쉬워보였던 부분도 영향이 있다 생각한다.
       

 > 하지만 Class를 사용해야한다는 생각이 든다 왜?
    >> function component보다 불편한건 확실하지만, 리액트의 전체적인 흐름을 알아야하는 부분에서 꼭 필요하다 생각.
    >> 비록 function 형식이 최신이라 하지만, 기존 리액트, 자바스크립트 유저와 자료가 월등히 많기 때문에
        그리고 각 상황(라이프사이클)에 동작하는 코드를 넣고싶을떄는 클래스를 이용 할 수 밖에 없다는 것이 큰 이유다.

 > Life Cycle(생명주기), Hook(useState, useEffect....)
    >> Life Cycle : 
        1.constructor(props) 
        컴포넌트가 새로 만들어 질 때마다 호출된다. 
        프로젝트 구동시 여러 이벤트로 인해 한 컴포넌트가 여러번 생성되고 삭제됨을 반복하기도 하는데 새로 생성될 때 마다 constructor가 실행된다
        
        2.componentWillMount:
        React 엘리먼트를 실제 DOM 노드에 추가하기 직전에 호출되는 메소드다.
        DOM이 생성되지 않았으므로 DOM을 조작할 수 없고, render가 호출되기 전이기 때문에 setState를 사용해도 render가 호출하지 않는다.
        
        3.render():
        컴포넌트 렌더링을 담당한다.
        
        4.componentDidMount:
        가상 DOM에서 실제 DOM으로 반영된 이후에 실행된다. 
        주로 실제 dom을 사용해야 하는 외부 라이브러리를 사용할 때나 네트워크 자원을 요청하는 로직을 수행한다.
        ....
        (정말 많지만 아직 이해하기 어려움이 있고, 계속 공부를 해야한다)

        쓰는 이유 : 
        각 상황(진행도)에 따라서 원하는 형식으로 커스터마이징이 보다 세밀하게 진행할수있다.

        5. 

    >> Hook :
        Hook은 함수 컴포넌트에서 React state와 생명주기 기능(lifecycle features)을 “연동(hook into)“할 수 있게 해주는 함수입니다. 
        (componentDidMount와 componentDidUpdate, componentWillUnmount를 결합한 것과 흡사.)
        Hook은 class 안에서는 동작하지 않습니다. 
        대신 class 없이 React를 사용할 수 있게 해주는 것입니다.

        * 쓰는 이유 : 
        Life Cycle에 자신의 코드와 로직이 밀접하게 결합되어있어, 결합하기가 쉽지않다.
        우선 functional-component(함수형)으로 시작했으며, Class형식이랑 가장 다른점 이라고 할 수 있는 부분이다.

       


    // BrowserRouter란? 
    > HTML5의 History API를 사용하여 페이지를 새로고침하지 않고도 주소를 변경할 수 있도록 해준다.
    > (즉, 페이지 변경으로 인한 깜빡거림이 없다.)
    > 또, 현재 주소에 관련된 정보를 props로 조회 및 사용이 가능하도록 만들어준다.

    Landing Page 아웃라인 설명.
        1. 기본적으로 react.Dom을 실행시키고, render가 되는 부분에서 시작을합니다.
        2. React.StrictMode를 감싸서 (컴포넌트는 문제가 발생하면, 발생된 에러메세지를 바로 출력하는 모드).
        3. Route. Switch는 react-router-dom 라이브러리를 사용해서 진행을 했음.
        4. Landing.js에서 function(const Landing =()=> {...})을 기준으로 실행이되고.
        5. 스크립트단에서는 기본적인 HTML로 뼈대를 만들었습니다, 그리고 섹션별로 나눠 총 5페이지를 제작.
        6. Css를 따로 CssFolder.js로 모와놨고, 각 HTML에 className을 사용하여 디자인했습니다.
        7. 그리고 자바스크립트 기능 부분은 Page Scroll, 상품 Slider, API연결 및 데이터전달로 구현했습니다.
        age Scroll, 
        상품 Slider,
        API연결 : 데이터는 useEffect를 사용하고 axios를  API과 연결하였습니다,
            Slider부분은 따로 컴포넌트로 만들어서, import 하였고, 구조분해로 할당하여, 
            (data, containerCss, itemCss, contentCss, imgCss, onClickEvent)을 가져올수있도록 설정했습니다.
            - 또한 자료를 가져오는 방식으로 많이 고생했는데, 우선 .get으로 미리 urls에 등록한 주소를 가져오고, 
            - .then으로 response안에 있는 data. code === "1" 이라는 조건이 부합하게 만듭니다.
            - 그리고 거기서 JSON으로 perse를 하여, data.msg에 데이터를 가져옵니다
                const parseJson = JSON.parse(res.data.msg);
                const aaaa = parseJson.item;
                const RevArr = [];
                * RevArr이라는 배열을 만들어주고.
            - aaaa.map((item) =>
                RevArr.push({...
            - 이제 이런식으로 map을 해서 한뭉텅이인 데이터를, 구조적인 형태로 만듭니다.
            - 그리고 그안에 이름을 item이라 설정합니다.
            - 그안에   
            id: item.id,
            img: item.product.thumnail,
            content: RVslideElement(    <= 이부분이 정말 신기했는데요, 따로 Element 컴포넌트로 만들어서 필요한 자료를 가져오는 방식. 
                item.product.name,
                item.point,
                item.description

        8. react-bootstrap을 사용하여 Modal 기능을 구현했습니다.
        9. Slider, StarPoint처럼 각자 컴포넌트를 나누고, 그안에서 Element로 가져오는 구조로 진행이 되었습니다 
        10.Slider, StarPoint는 기본적으로 propTypes를 사용한 props 전달구조로 만들었으며, 
            스크립트단에서 모듈화된 컴포넌트에서 데이터 전달을 하도록 진행되었습니다.




































